# Контрольні запитання - Відповіді (Лабораторна робота №2)

## 1. Чому не рекомендується робити git add для файлів розміром 1GB+?

Git зберігає **повну копію кожної версії** файлу в папці `.git/objects`. При зміні 1GB файлу розмір репозиторію зростає на 1GB за кожен коміт — навіть якщо змінився один рядок. Це призводить до:

- **Розростання `.git` папки** до десятків гігабайт
- **Повільного `git clone`, `git pull`, `git push`**
- **Перевищення лімітів** хостингу (GitHub: 100MB на файл, 5GB на репозиторій)

**Рішення:** DVC зберігає у Git лише `.dvc`-метафайл (~300 байт) з хешем, а реальний файл — у зовнішньому сховищі.

---

## 2. Яку роль виконує файл .dvc (наприклад, `dataset.csv.dvc`)?

Це легкий метафайл-замінник реального файлу даних у Git. Містить:

```yaml
outs:
  - md5: a1b2c3d4e5f6...   # SHA256-хеш реального файлу
    size: 1073741824         # розмір у байтах
    path: dataset.csv
```

**Функції:**
- Дозволяє Git відстежувати **версію даних** без самих даних
- За хешем DVC знаходить файл у кеші або сховищі (remote)
- `dvc pull` відновлює реальний файл із хешу

---

## 3. Що таке `dvc.lock` і чому його потрібно комітити в Git?

`dvc.lock` — знімок стану всього пайплайну на момент успішного виконання. Для кожної стадії фіксує MD5-хеші всіх `deps` та `outs`:

```yaml
stages:
  prepare:
    cmd: python src/prepare.py data/raw/chest_xray data/prepared
    deps:
    - path: data/raw/chest_xray
      md5: 3a7b9f...
    - path: src/prepare.py
      md5: c4d8e1...
    outs:
    - path: data/prepared
      md5: 9f2a4b...
```

**Чому комітити:**
- Гарантує **відтворюваність**: колега знає точно, з яких даних отримано модель
- DVC порівнює поточні хеші з `dvc.lock`, щоб вирішити які стадії пропустити
- У CI/CD можна верифікувати: чи модель навчена на сертифікованих даних

---

## 4. Як DVC розуміє, що стадію `prepare` не потрібно перезапускати?

При `dvc repro` DVC обчислює MD5-хеші всіх `deps` стадії та порівнює з `dvc.lock`:

```
Поточний хеш src/prepare.py  ==  хеш у dvc.lock  →  файл не змінився
Поточний хеш data/raw/       ==  хеш у dvc.lock  →  дані не змінились
                                                    → Stage 'prepare' didn't change, skipping
```

Якщо **хоча б один** dep або `cmd` змінився — стадія перезапускається, і всі залежні від неї стадії теж.

---

## 5. Ви змінили сирі дані. Які кроки потрібно виконати?

Припустимо, ви додали нові зображення до `data/raw/chest_xray`:

```bash
# 1. Оновити DVC-трекінг (перерахує хеш і оновить .dvc файл)
dvc add data/raw/chest_xray

# 2. Запустити пайплайн — DVC побачить зміну хешу і перезапустить всі стадії
dvc repro

# 3. Зафіксувати нову версію даних і стану пайплайну в Git
git add data/raw/chest_xray.dvc dvc.lock
git commit -m "Update dataset: added 200 new PNEUMONIA images"

# 4. Відправити нову версію даних у сховище
dvc push
```

Тепер і стара і нова версії даних відновлювані через `git checkout` + `dvc pull`.

---

## 6. Чим відрізняється `dvc push` від `git push`?

| | `git push` | `dvc push` |
|---|---|---|
| **Що відправляє** | Код, метафайли (.dvc, dvc.lock), конфіги | Реальні файли даних і моделей |
| **Куди** | GitHub / GitLab / Bitbucket | DVC Remote (S3, GCS, Azure, локальна папка) |
| **Що лежить там** | Commit history, branches | Content-addressed cache (файли за MD5-хешем) |
| **Розмір** | Кілобайти | Гігабайти |

**Правильний workflow:**
```bash
git push        # код + метафайли
dvc push        # бінарні дані + моделі
```

---

## 7. Результат погіршився після зміни препроцесингу. Як повернутися назад?

DVC + Git дають **точний часовий зворот** до будь-якого стану:

```bash
# 1. Знайти потрібний коміт
git log --oneline

# 2. Повернути код і метафайли (dvc.lock, .dvc файли) до попереднього стану
git checkout <commit-hash>

# 3. Завантажити відповідну версію ДАНИХ і МОДЕЛІ з DVC-сховища
dvc checkout   # відновлює data/ і models/ за хешами з dvc.lock
# або
dvc pull       # теж завантажить, якщо немає в локальному кеші
```

Після цього у вас: старий код (`src/`), старі дані (`data/prepared/`), стара модель (`models/`) — точно той стан, що давав кращий результат.

---

## 8. Як використати `dvc.lock` у CI/CD (GitHub Actions)?

`dvc.lock` містить хеші даних, на яких навчена модель. У CI можна верифікувати відповідність:

```yaml
# .github/workflows/validate.yml
name: Validate Pipeline
on: [push]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup DVC
        run: pip install dvc

      - name: Configure DVC remote
        run: dvc remote modify mylocal url ${{ secrets.DVC_REMOTE_URL }}

      - name: Pull data для перевірки
        run: dvc pull

      - name: Перевірити що пайплайн актуальний
        run: |
          dvc repro --dry   # показує що буде перезапущено, не запускаючи
          dvc status        # якщо є зміни — вихід буде ненульовим
```

**Що це дає:**
- `dvc status` повертає ненульовий код виходу, якщо `dvc.lock` не відповідає реальним файлам → CI провалюється
- Гарантія: модель у `models/` навчена **саме на тих даних**, що зафіксовані в `dvc.lock` у поточному коміті
